// generated by tool/make_ast.py, do not modify!
package parser

import "toe/lexer"

const (
	_ = NodeType(iota)
	LET
	BLOCK
	FOR
	WHILE
	IF
	EXPR_STMT
	BREAK
	CONTINUE
	RETURN
	BINARY
	AND
	OR
	ASSIGN
	UNARY
	GET
	SET
	CALL
	IDENTIFIER
	LITERAL
	FUNCTION
)

type Let struct {
	Token lexer.Token
	Name  lexer.Token
	Value Expr
}

func (node *Let) Tok() lexer.Token { return node.Token }
func (node *Let) Type() NodeType   { return LET }
func (node *Let) stmt()            {}

type Block struct {
	Token      lexer.Token
	Statements []Stmt
}

func (node *Block) Tok() lexer.Token { return node.Token }
func (node *Block) Type() NodeType   { return BLOCK }
func (node *Block) stmt()            {}

type For struct {
	Token lexer.Token
	Name  Expr
	Iter  Expr
	Stmt  Stmt
}

func (node *For) Tok() lexer.Token { return node.Token }
func (node *For) Type() NodeType   { return FOR }
func (node *For) stmt()            {}

type While struct {
	Token lexer.Token
	Cond  Expr
	Stmt  Stmt
}

func (node *While) Tok() lexer.Token { return node.Token }
func (node *While) Type() NodeType   { return WHILE }
func (node *While) stmt()            {}

type If struct {
	Token lexer.Token
	Cond  Expr
	Then  Stmt
	Else  Stmt
}

func (node *If) Tok() lexer.Token { return node.Token }
func (node *If) Type() NodeType   { return IF }
func (node *If) stmt()            {}

type ExprStmt struct {
	Token lexer.Token
	Expr  Expr
}

func (node *ExprStmt) Tok() lexer.Token { return node.Token }
func (node *ExprStmt) Type() NodeType   { return EXPR_STMT }
func (node *ExprStmt) stmt()            {}

type Break struct {
	Token lexer.Token
}

func (node *Break) Tok() lexer.Token { return node.Token }
func (node *Break) Type() NodeType   { return BREAK }
func (node *Break) stmt()            {}

type Continue struct {
	Token lexer.Token
}

func (node *Continue) Tok() lexer.Token { return node.Token }
func (node *Continue) Type() NodeType   { return CONTINUE }
func (node *Continue) stmt()            {}

type Return struct {
	Token lexer.Token
	Expr  Expr
}

func (node *Return) Tok() lexer.Token { return node.Token }
func (node *Return) Type() NodeType   { return RETURN }
func (node *Return) stmt()            {}

type Binary struct {
	Token lexer.Token
	Left  Expr
	Right Expr
}

func (node *Binary) Tok() lexer.Token { return node.Token }
func (node *Binary) Type() NodeType   { return BINARY }
func (node *Binary) expr()            {}

type And struct {
	Token lexer.Token
	Left  Expr
	Right Expr
}

func (node *And) Tok() lexer.Token { return node.Token }
func (node *And) Type() NodeType   { return AND }
func (node *And) expr()            {}

type Or struct {
	Token lexer.Token
	Left  Expr
	Right Expr
}

func (node *Or) Tok() lexer.Token { return node.Token }
func (node *Or) Type() NodeType   { return OR }
func (node *Or) expr()            {}

type Assign struct {
	Token lexer.Token
	Name  lexer.Token
	Right Expr
}

func (node *Assign) Tok() lexer.Token { return node.Token }
func (node *Assign) Type() NodeType   { return ASSIGN }
func (node *Assign) expr()            {}

type Unary struct {
	Token lexer.Token
	Right Expr
}

func (node *Unary) Tok() lexer.Token { return node.Token }
func (node *Unary) Type() NodeType   { return UNARY }
func (node *Unary) expr()            {}

type Get struct {
	Token  lexer.Token
	Object Expr
	Name   lexer.Token
	Bound  bool
}

func (node *Get) Tok() lexer.Token { return node.Token }
func (node *Get) Type() NodeType   { return GET }
func (node *Get) expr()            {}

type Set struct {
	Token  lexer.Token
	Object Expr
	Name   lexer.Token
	Right  Expr
	Bound  bool
}

func (node *Set) Tok() lexer.Token { return node.Token }
func (node *Set) Type() NodeType   { return SET }
func (node *Set) expr()            {}

type Call struct {
	Token lexer.Token
	Fn    Expr
	Args  []Expr
}

func (node *Call) Tok() lexer.Token { return node.Token }
func (node *Call) Type() NodeType   { return CALL }
func (node *Call) expr()            {}

type Identifier struct {
	Token lexer.Token
}

func (node *Identifier) Tok() lexer.Token { return node.Token }
func (node *Identifier) Type() NodeType   { return IDENTIFIER }
func (node *Identifier) expr()            {}

type Literal struct {
	Token lexer.Token
}

func (node *Literal) Tok() lexer.Token { return node.Token }
func (node *Literal) Type() NodeType   { return LITERAL }
func (node *Literal) expr()            {}

type Function struct {
	Token  lexer.Token
	Params []lexer.Token
	Body   *Block
}

func (node *Function) Tok() lexer.Token { return node.Token }
func (node *Function) Type() NodeType   { return FUNCTION }
func (node *Function) expr()            {}

func newLet(Token lexer.Token, Name lexer.Token, Value Expr) *Let {
	return &Let{Token: Token, Name: Name, Value: Value}
}

func newBlock(Token lexer.Token, Statements []Stmt) *Block {
	return &Block{Token: Token, Statements: Statements}
}

func newFor(Token lexer.Token, Name Expr, Iter Expr, Stmt Stmt) *For {
	return &For{Token: Token, Name: Name, Iter: Iter, Stmt: Stmt}
}

func newWhile(Token lexer.Token, Cond Expr, Stmt Stmt) *While {
	return &While{Token: Token, Cond: Cond, Stmt: Stmt}
}

func newIf(Token lexer.Token, Cond Expr, Then Stmt, Else Stmt) *If {
	return &If{Token: Token, Cond: Cond, Then: Then, Else: Else}
}

func newExprStmt(Token lexer.Token, Expr Expr) *ExprStmt { return &ExprStmt{Token: Token, Expr: Expr} }

func newBreak(Token lexer.Token) *Break { return &Break{Token: Token} }

func newContinue(Token lexer.Token) *Continue { return &Continue{Token: Token} }

func newReturn(Token lexer.Token, Expr Expr) *Return { return &Return{Token: Token, Expr: Expr} }

func newBinary(Token lexer.Token, Left Expr, Right Expr) *Binary {
	return &Binary{Token: Token, Left: Left, Right: Right}
}

func newAnd(Token lexer.Token, Left Expr, Right Expr) *And {
	return &And{Token: Token, Left: Left, Right: Right}
}

func newOr(Token lexer.Token, Left Expr, Right Expr) *Or {
	return &Or{Token: Token, Left: Left, Right: Right}
}

func newAssign(Token lexer.Token, Name lexer.Token, Right Expr) *Assign {
	return &Assign{Token: Token, Name: Name, Right: Right}
}

func newUnary(Token lexer.Token, Right Expr) *Unary { return &Unary{Token: Token, Right: Right} }

func newGet(Token lexer.Token, Object Expr, Name lexer.Token, Bound bool) *Get {
	return &Get{Token: Token, Object: Object, Name: Name, Bound: Bound}
}

func newSet(Token lexer.Token, Object Expr, Name lexer.Token, Right Expr, Bound bool) *Set {
	return &Set{Token: Token, Object: Object, Name: Name, Right: Right, Bound: Bound}
}

func newCall(Token lexer.Token, Fn Expr, Args []Expr) *Call {
	return &Call{Token: Token, Fn: Fn, Args: Args}
}

func newIdentifier(Token lexer.Token) *Identifier { return &Identifier{Token: Token} }

func newLiteral(Token lexer.Token) *Literal { return &Literal{Token: Token} }

func newFunction(Token lexer.Token, Params []lexer.Token, Body *Block) *Function {
	return &Function{Token: Token, Params: Params, Body: Body}
}
