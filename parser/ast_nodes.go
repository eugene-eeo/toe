// generated by tool/make_ast.py, do not modify!
package parser

import "toe/lexer"

type Module struct {
	Filename string
	Stmts    []Stmt
}

func newModule(Filename string, Stmts []Stmt) *Module {
	return &Module{
		Filename: Filename,
		Stmts:    Stmts,
	}
}
func (node *Module) node() {}
func (node *Module) stmt() {}

type Let struct {
	Name  lexer.Token
	Value Expr
}

func newLet(Name lexer.Token, Value Expr) *Let {
	return &Let{
		Name:  Name,
		Value: Value,
	}
}
func (node *Let) node() {}
func (node *Let) stmt() {}

type Block struct {
	Stmts []Stmt
}

func newBlock(Stmts []Stmt) *Block {
	return &Block{
		Stmts: Stmts,
	}
}
func (node *Block) node() {}
func (node *Block) stmt() {}

type For struct {
	Name lexer.Token
	Iter Expr
	Stmt Stmt
}

func newFor(Name lexer.Token, Iter Expr, Stmt Stmt) *For {
	return &For{
		Name: Name,
		Iter: Iter,
		Stmt: Stmt,
	}
}
func (node *For) node() {}
func (node *For) stmt() {}

type While struct {
	Cond Expr
	Stmt Stmt
}

func newWhile(Cond Expr, Stmt Stmt) *While {
	return &While{
		Cond: Cond,
		Stmt: Stmt,
	}
}
func (node *While) node() {}
func (node *While) stmt() {}

type If struct {
	Cond Expr
	Then Stmt
	Else Stmt
}

func newIf(Cond Expr, Then Stmt, Else Stmt) *If {
	return &If{
		Cond: Cond,
		Then: Then,
		Else: Else,
	}
}
func (node *If) node() {}
func (node *If) stmt() {}

type ExprStmt struct {
	Expr Expr
}

func newExprStmt(Expr Expr) *ExprStmt {
	return &ExprStmt{
		Expr: Expr,
	}
}
func (node *ExprStmt) node() {}
func (node *ExprStmt) stmt() {}

type Break struct {
	Keyword lexer.Token
}

func newBreak(Keyword lexer.Token) *Break {
	return &Break{
		Keyword: Keyword,
	}
}
func (node *Break) node() {}
func (node *Break) stmt() {}

type Continue struct {
	Keyword lexer.Token
}

func newContinue(Keyword lexer.Token) *Continue {
	return &Continue{
		Keyword: Keyword,
	}
}
func (node *Continue) node() {}
func (node *Continue) stmt() {}

type Return struct {
	Keyword lexer.Token
	Expr    Expr
}

func newReturn(Keyword lexer.Token, Expr Expr) *Return {
	return &Return{
		Keyword: Keyword,
		Expr:    Expr,
	}
}
func (node *Return) node() {}
func (node *Return) stmt() {}

type Binary struct {
	Left  Expr
	Op    lexer.Token
	Right Expr
}

func newBinary(Left Expr, Op lexer.Token, Right Expr) *Binary {
	return &Binary{
		Left:  Left,
		Op:    Op,
		Right: Right,
	}
}
func (node *Binary) node() {}
func (node *Binary) expr() {}

type And struct {
	Left  Expr
	Op    lexer.Token
	Right Expr
}

func newAnd(Left Expr, Op lexer.Token, Right Expr) *And {
	return &And{
		Left:  Left,
		Op:    Op,
		Right: Right,
	}
}
func (node *And) node() {}
func (node *And) expr() {}

type Or struct {
	Left  Expr
	Op    lexer.Token
	Right Expr
}

func newOr(Left Expr, Op lexer.Token, Right Expr) *Or {
	return &Or{
		Left:  Left,
		Op:    Op,
		Right: Right,
	}
}
func (node *Or) node() {}
func (node *Or) expr() {}

type Assign struct {
	Name  lexer.Token
	Right Expr
	Loc   int
}

func newAssign(Name lexer.Token, Right Expr) *Assign {
	return &Assign{
		Name:  Name,
		Right: Right,
	}
}
func (node *Assign) node() {}
func (node *Assign) expr() {}

type Unary struct {
	Op    lexer.Token
	Right Expr
}

func newUnary(Op lexer.Token, Right Expr) *Unary {
	return &Unary{
		Op:    Op,
		Right: Right,
	}
}
func (node *Unary) node() {}
func (node *Unary) expr() {}

type Get struct {
	Object Expr
	Name   lexer.Token
	Bound  bool
}

func newGet(Object Expr, Name lexer.Token, Bound bool) *Get {
	return &Get{
		Object: Object,
		Name:   Name,
		Bound:  Bound,
	}
}
func (node *Get) node() {}
func (node *Get) expr() {}

type Set struct {
	Object Expr
	Name   lexer.Token
	Bound  bool
	Right  Expr
}

func newSet(Object Expr, Name lexer.Token, Bound bool, Right Expr) *Set {
	return &Set{
		Object: Object,
		Name:   Name,
		Bound:  Bound,
		Right:  Right,
	}
}
func (node *Set) node() {}
func (node *Set) expr() {}

type Call struct {
	Callee Expr
	LParen lexer.Token
	Args   []Expr
}

func newCall(Callee Expr, LParen lexer.Token, Args []Expr) *Call {
	return &Call{
		Callee: Callee,
		LParen: LParen,
		Args:   Args,
	}
}
func (node *Call) node() {}
func (node *Call) expr() {}

type Identifier struct {
	Id  lexer.Token
	Loc int
}

func newIdentifier(Id lexer.Token) *Identifier {
	return &Identifier{
		Id: Id,
	}
}
func (node *Identifier) node() {}
func (node *Identifier) expr() {}

type Literal struct {
	Lit lexer.Token
}

func newLiteral(Lit lexer.Token) *Literal {
	return &Literal{
		Lit: Lit,
	}
}
func (node *Literal) node() {}
func (node *Literal) expr() {}

type Function struct {
	Fn     lexer.Token
	Params []lexer.Token
	Body   *Block
}

func newFunction(Fn lexer.Token, Params []lexer.Token, Body *Block) *Function {
	return &Function{
		Fn:     Fn,
		Params: Params,
		Body:   Body,
	}
}
func (node *Function) node() {}
func (node *Function) expr() {}

type Super struct {
	Tok   lexer.Token
	Name  lexer.Token
	Bound bool
}

func newSuper(Tok lexer.Token, Name lexer.Token, Bound bool) *Super {
	return &Super{
		Tok:   Tok,
		Name:  Name,
		Bound: Bound,
	}
}
func (node *Super) node() {}
func (node *Super) expr() {}
