#
#   make_ast.py
#   ~~~~~~~~~~~
#
#   generates ast nodes for the toe language.
#

import os
from subprocess import Popen, PIPE


package_template = """\
// generated by tool/make_ast.py, do not modify!
package parser

import "toe/lexer"

const (
\t_ = NodeType(iota)
{types}
)

{structs}

{functions}
"""

struct_template = """\
type {name} struct {{
{fields}
}}

{methods}
"""

meth_template = "func (node *{name}) {func_name}() {type} {{ {body} }}"
func_template = "func new{name}({args}) *{name} {{ return &{name}{{ {props} }} }}"  # noqa: E501

FUNCS = []
TYPES = []
STRUCTS = []
STRUCT_TYPES = []


def node(type, name, *, fields, is_expression):
    fields = ['Token lexer.Token'] + fields
    set_fields = []
    for field in fields:
        field_name, _ = field.split(' ', 1)
        set_fields.append(f"{field_name}: {field_name}")
    constructor = func_template.format(
        name=name,
        args=', '.join(fields),
        props=', '.join(set_fields),
    )
    methods = [
        meth_template.format(
            name=name, func_name=func_name, type=type, body=body)
        for func_name, type, body
        in [
            ('Tok', 'lexer.Token', 'return node.Token'),
            ('Type', 'NodeType', f'return {type}'),
            ('expr', '', '') if is_expression else ('stmt', '', ''),
        ]
    ]
    STRUCT_TYPES.append(name)
    FUNCS.append(constructor)
    TYPES.append(type)
    STRUCTS.append(struct_template.format(
        name=name,
        fields="\n".join(f"\t{field}" for field in fields),
        methods="\n".join(methods),
    ))


def expr(*args, **kwargs):
    return node(*args, is_expression=True, **kwargs)


def stmt(*args, **kwargs):
    return node(*args, is_expression=False, **kwargs)


def generate():
    if len(set(TYPES)) != len(set(STRUCT_TYPES)):
        print("Expected same number of NodeType constants as struct types", file=os.stderr)
        os.exit(1)
    input = package_template.format(
        functions="\n\n".join(FUNCS),
        types="\n".join(TYPES),
        structs="\n".join(STRUCTS),
    )
    input = input.encode('utf-8')
    with Popen(['gofmt'], stdout=PIPE, stderr=PIPE, stdin=PIPE) as proc:
        proc.stdin.write(input)
        proc.stdin.flush()
        proc.stdin.close()
        err = proc.stderr.read()
        if err:
            print("----------------")
            print("Error:")
            print(err)
            print("----------------")
            os.exit(1)
        with open('./parser/ast_nodes.go', mode='wb') as fp:
            fp.write(proc.stdout.read())


# ======================
# Put declarations here!
# ======================

if __name__ == '__main__':
    # autopep8: off
    # Statements
    stmt('LET', 'Let', fields=['Name lexer.Token', 'Value Expr'])
    stmt('BLOCK', 'Block', fields=['Statements []Stmt'])
    stmt('FOR', 'For', fields=['Name Expr', 'Iter Expr', 'Stmt Stmt'])
    stmt('WHILE', 'While', fields=['Cond Expr', 'Stmt Stmt'])
    stmt('IF', 'If', fields=['Cond Expr', 'Then Stmt', 'Else Stmt'])
    stmt('EXPR_STMT', 'ExprStmt', fields=['Expr Expr'])
    stmt('BREAK', 'Break', fields=[])
    stmt('CONTINUE', 'Continue', fields=[])
    # Expressions
    expr('BINARY', 'Binary', fields=['Left Expr', 'Right Expr'])
    expr('AND', 'And', fields=['Left Expr', 'Right Expr'])
    expr('OR', 'Or', fields=['Left Expr', 'Right Expr'])
    expr('ASSIGN', 'Assign', fields=['Name lexer.Token', 'Right Expr'])
    expr('UNARY', 'Unary', fields=['Right Expr'])
    expr('GET', 'Get', fields=['Object Expr', 'Name lexer.Token', 'Bound bool'])
    expr('SET', 'Set', fields=['Object Expr', 'Name lexer.Token', 'Right Expr', 'Bound bool'])
    expr('IDENTIFIER', 'Identifier', fields=[])
    expr('LITERAL', 'Literal', fields=[])
    # autopep8: on
    generate()
